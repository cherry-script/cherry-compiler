// The following file is a complete and valid Ren module, designed to showcase
// all the syntax features of the language. If this module compiles, then we can
// be reasonably sure the compiler will handle most code users will write. If not,
// there's a bug!

// As we've already seen one, let's first look at comments. Ren only has line
// comments. They should be valid everywhere, with the parser simply ignoring
// everything from the `//` to the end of the line.

// IMPORTS ---------------------------------------------------------------------

// The idiomatic way to handle imports in Ren code is to import a module and qualify
// it with some namespace, as demonstrated below. Note that the namespace may be 
// broken up by periods.
import 'ren/array' as Ren.Array
import 'ren/array' exposing { map }
import 'ren/array' as Ren.Array exposing { map }

// Imports can also be just for their side effects, although this is only really
// useful when importing JavaScript directly.
import 'some-effectful-module'

// The compiler is ostensibly concerned with simply turning Ren source files into
// compiled JavaScrpt ones. It's down to individual tooling to manage imports and
// dependencies. As a consequence, there aren't really any formal rules for what
// *can* be imported. In the experimental Advent of Code runner, for example, we
// have imports like:
import './util' as Util
import 'pkg ren/array' as Array
import 'ext performance-timing' as Perf
// to differentiate between local imports, ren package imports, and external js
// imports.

// DECLARATIONS ----------------------------------------------------------------

// `let` declarations are like `const` in JavaScript, they bind a name to a value.
let x = 10

// These declarations (like all declarations) can be made _public_ so they can be
// imported in other modules with the `pub` modifier:
pub let y = 5

// NOTE: When compiling with optimisations enabled, dead code elimination will
// remove any unused bindings. In this case the `x` declaration would be removed
// from the compiled JavaScript output because it's not used in any "live" code!
//
// When using this file to verify the compiler, unless you're explicitly testing
// them, it's probably a good idea to leave optimisations disabled so you can 
// be sure *everything* compiles and emits properly.

// Function declarations
fun f = a b => a + b

// It is possible to pattern match in function arguments. We might destructure
// an object or match against a single enum variant:
fun f = { a } (#just b) => a + b